import java_cup.runtime.*;

parser code {: :};
action code {: :};

/* ----- Terminals from tokens.jflex / Project 2 spec ----- */
terminal CLASS, AND, ELSE, IF, WHILE, READ, PRINT, PRINTLINE, RETURN;
terminal OR, MULT, PLUS, MINUS, DIV, SEMI, LPAREN, RPAREN;
terminal LBRACKET, RBRACKET, LBRACE, RBRACE, INC, DEC;
terminal LT, GT, LE, GE, EQEQ, NE, NOT, QMARK, COLON, EQ, COMMA;
terminal VOID, INT, FLOAT, BOOL, CHAR, TRUE, FALSE, FINAL;
terminal ERROR;

terminal String ID;
terminal String INTLIT;
terminal String FLOATLIT;
terminal String CHARLIT;
terminal String STRLIT;

/* ----- Non-terminals typed to your AST ----- */
non terminal Program program;
non terminal StmtList stmts;
non terminal Stmt stmt;
non terminal Expr expr;

/* ----- Precedence (per Project 2 Phase 1 expr rules) ----- */
precedence right QMARK, COLON;
precedence left OR;
precedence left AND;
precedence left EQEQ, NE;
precedence left LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence right NOT;

/* ----- Start ----- */
start with program;

/* ----- Productions ----- */

/* Program → Stmts */
program ::=
    stmts:s
    {: RESULT = new Program(s); :}
    ;

/* Stmts → Stmt Stmts | λ */
stmts ::=
    stmt:s stmts:ss
    {: ss.prepend(s); RESULT = ss; :}
  | /* empty */
    {: RESULT = new StmtList(); :}
    ;

/* Stmt → Name = Expr ;  (Phase 1 subset: just simple ID for Name) */
stmt ::=
    ID:name EQ expr:e SEMI
    {: RESULT = new AssignStmt(name, e); :}
    ;

/* Expr rules: basic arithmetic + parens + ids + intlits */
expr ::=
    expr:e1 PLUS expr:e2
    {: RESULT = new BinaryExpr(e1, "+", e2); :}
  | expr:e1 MINUS expr:e2
    {: RESULT = new BinaryExpr(e1, "-", e2); :}
  | expr:e1 MULT expr:e2
    {: RESULT = new BinaryExpr(e1, "*", e2); :}
  | expr:e1 DIV expr:e2
    {: RESULT = new BinaryExpr(e1, "/", e2); :}
  | LPAREN expr:e RPAREN
    {: RESULT = e; :}
  | ID:name
    {: RESULT = new VarExpr(name); :}
  | INTLIT:n
    {: RESULT = new IntLiteral(n); :}
    ;

